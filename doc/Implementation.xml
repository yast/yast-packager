<chapter><title>Implementation</title>

<para>
<itemizedlist>
<listitem><para>installation sources provide selections (set of packages) and
  packages.
</para></listitem>
<listitem><para>installation source has unique ID and 'cache file' which is
  stored at registration time to identify the source
</para></listitem>
<listitem><para>Pre-Require flags might be used to order packages during installation
</para></listitem>
<listitem><para>Package list on installation media determines installation order.
Still a number of packages (currently called ELF packs) must be pre-installed
by force. Possibly using a .tar.bz2 could be feasible (-> autobuild team)
</para></listitem>
<listitem><para>Autobuild needs a solver to determine how to spread packages across
  multiple CDs
</para></listitem>
<listitem><para>Selections have dependencies and versions, so the same code can be
  used for selections and packages
</para></listitem>
<listitem><para>Update server (YOU) can be implemented as an installation source (with
  a high priority).
</para></listitem>
</itemizedlist>
</para>

<section><title>5.8 Installation Source</title>
<para>
- how to identify an installation source (setup/descr/info, update.inf)

A package source is represented in a piece of code (c++ object) with
a common frontend (interface) and a source (media) specific backend.

The following functionality should be provided
<itemizedlist>
<listitem><para>init package source (kind of source, ranking, status, ...)
</para></listitem>
<listitem><para>query package source (all attributes from III.3)
</para></listitem>
<listitem><para>query selection (provided by package source)
</para></listitem>
<listitem><para>query package (provided by package source)
</para></listitem>
</itemizedlist>
</para>

<para>
A package source interface handles only information about selections
and packages, but not the package contents itself.
Transferring the package contents (installing the package) is done
directly on the target system, usually by mounting a package source
media or calling ftp.</para>
<para>
The <emphasis>package provider</emphasis> is reponsible for providing a package in a way
accessible by the package drain (the target system).
</para>
<para>
A possible dataflow could be as possible
<itemizedlist>
<listitem><para>package source provides a set of selections/packages
</para></listitem>
<listitem><para>dependency solver computes a list of packages to be installed
</para></listitem>
<listitem><para>control unit loops through this list and calls the package
  source (manager) to provide a package for access, the result
  of such an access command is a URL for package access.
  (i.e. file:/var/adm/mount/suse/a1/aaa_base-8.1-42.i386.rpm)
</para></listitem>
<listitem><para>control unit calls package drain with the provided URL
</para></listitem>
<listitem><para>package drain tries to access and install the package
</para></listitem>
</itemizedlist>
</para>

<para>
If a package URL can't be accessed, an error code is returned by
the package drain. There are three classes of errors, fatal,
retryable, and dontcare. Fatal errors denoted failed package
installation, i.e. due to media failures.
Retryable errors are passed to the package source and could
be used to initiate change of physical medium (please insert
CD x) and a retry of the package access.
Dontcare errors could be used to suppress warnings if the user
deliberately ignored dependency errors.
</para>

</section>
<section><title>5.9 Package Provider</title>

<para>
The package provider retrieves a package to a (local) directory
x
</para>
</section>

<section><title>5.10 Installation Source Manager</title>
<para>
A package source manager eases the handling of multiple package
sources. It basically provides the same interface as a normal
package source, as it also provides selections and packages.

Additionally it provides functions to
<itemizedlist>
<listitem><para>add</para></listitem>
<listitem><para>delete</para></listitem>
<listitem><para>query</para></listitem>
</itemizedlist>
package sources.
</para>

<para>
For the dependency solver, it could be easiest to hide different
package sources in package attributes and let the package source
manager provide package with different attributes (name, version,
architecture, vendor, package source)
</para>
</section>

<section><title>5.11 Installation Target</title>
<para></para>
</section>
<section><title>Dependency Solver</title>
<para></para>
</section>
</chapter>

